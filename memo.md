## テスト駆動開発
「動作するきれいなコード」

### TDDのサイクル
#### おおまかに
まず動作するコードをつくってから、 きれいなコードにする
red, green, refactor
redの状態で、リファクタリングしない

#### すこし細かく
 1. 次の目標を考える
 2. そのおm苦行を示すテストを書く
 3. そのテストを実行して失敗させる(red)
 4. 目的のコードを書く(どんな手を使っても)
 5. 2で書いたテストを成功させる(green)
 6. テストが通るまでリファクタリングを行う(refactor) テストコード、プロダクトコード両方、時間は10分程度
 7. 1～6を繰り返す

### todoリストを書き出す
- 最初のテストは、重要度よりも、テスト容易性で選ぶ
- うまく分割して、重要度とテスト容易性を一致させる
- テストは動作するドキュメント

#### テスト容易性Low 重要度Low
- [x] 数を文字列に変換する
  - [x] 1を渡すと、文字列"1"を返す → 仮実装
  - [x] 2を渡すと、文字列"2"を返す → 三角測量
- [x] 3の倍数のときは、数の代わりに「Fizz」と変換する
  - [x] 3を渡すと、文字列"Fizz"を返す → 仮実装 → 実装
- [x] 5の倍数のときは、数の代わりに「Buzz」と変換する
  - [x] 5を渡すと、文字列"Buzz"を返す → 明白な実装
- [x] 3と5の倍数のときは、数の代わりに「FizzBuzz」と変換する
  - [x] 15を渡すと、文字列"FizzBuzz"を返す → 明白な実装

#### テスト容易性Low 重要度Low
- [x] 1からnまで  
  - [x] 1から15までの数を渡すと、「1 2 Fizz 3 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz」を返す
- [ ] プリントする  

### TDDのスキル
- 問題を小さく分割する
- 歩幅を調整する
  - テスト → 仮実装 → 三角測量 → 実装
  - テスト → 仮実装 → 実装
  - テスト → 明白な実装
- テストの構造化とリファクタリング

### clojure.test
テストの実行順は、上から順次固定
use-fixtures
